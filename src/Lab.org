#+title: 学校作业记录
* 综合课程设计题目
** 10.1.1 线性表
这次实践选了三个简单的A级题目，要是没把以前的仓库删了，C级题目就能写了
*** A1 Josephus 环问题 
**** 题目描述
判决 =length= 个犯人的死刑，让犯人站成一个圈，从 =start= 开始暑期，每数到 =distance= 个犯人，就拉出来处决
然后再从下一个开始数 =distance= 个，数到的人再处决，知道剩下最后一个犯人予以赦免
**** 分析
1. =josephus= 环的问题我用循环链表来解决，由于标准库里没有这个数据结构，这里我手动调整下迭代器的位置就够了
2. 这个程序有终止条件，当 *犯人数量* 为 1 时停止
**** 函数说明
=int josephus(int length, int start, int distance)=
- 传入犯人的数量 =length= ，从第 =start= 开始，间隔为 =distance=
- 数到第 =distance= 个犯人时,将当前迭代器删除
- 函数返回存活的犯人编号
**** 完整代码
#+begin_src c++
  int josephus(int length, int start, int distance) {
    list<int> prisoners;

    for (int i = 1; i <= length; i += 1) {
      prisoners.push_back(i);
    }

    list<int>::iterator it = next(prisoners.begin(), start - 1);
    while (true) {
      if (prisoners.size() == 1) {
        break;
      }

      // list<int>::iterator target = next(it, distance - 1);
      list<int>::iterator target = it;
      for (int i = 2; i <= distance; i += 1) {
        target = next(target);
        if (target == prisoners.end()) {
          target = prisoners.begin();
        }
      }

      it = next(target);
      prisoners.erase(target);

      if (it == prisoners.end()) {
        it = prisoners.begin();
      }
    }

    return prisoners.front());
  }

#+end_src

**** 测试案例
- 测试代码
#+begin_src c++
  int main() {
    cout << "josephus(3, 2, 3)" << '\t' << josephus(3, 2, 3) << endl;
    cout << "josephus(4, 2, 3)" << '\t' << josephus(4, 2, 3) << endl;
    cout << "josephus(5, 2, 3)" << '\t' << josephus(5, 2, 3) << endl;
    cout << "josephus(6, 2, 3)" << '\t' << josephus(6, 2, 3) << endl;
    cout << "josephus(7, 2, 3)" << '\t' << josephus(7, 2, 3) << endl;
    cout << "josephus(8, 2, 3)" << '\t' << josephus(8, 2, 3) << endl;
    cout << "josephus(9, 2, 3)" << '\t' << josephus(9, 2, 3) << endl;
    cout << "josephus(10, 2, 3)" << '\t' << josephus(10, 2, 3) << endl;

    return 0;
  }

#+end_src

- 运行结果
#+begin_src c++
  josephus(3, 2, 3)	3
  josephus(4, 2, 3)	2
  josephus(5, 2, 3)	5
  josephus(6, 2, 3)	2
  josephus(7, 2, 3)	5
  josephus(8, 2, 3)	8
  josephus(9, 2, 3)	2
  josephus(10, 2, 3)	5

#+end_src
**** 时间复杂度
=O(n)=

*** A2 合并线性表
**** 题目描述
求两个集合的 =union= 操作，分别用顺序存储结构和链式存储结构实现
**** 分析
1. 有两个链表 =A= , =B=
2. 创建链表 =C= 为 =A= 的备份，再从 =B= 中提取不属于 =A= 的元素， 然后插入到 =C=
**** 函数说明
1. =list<int> union_list(list<int> & left, list<int> & right)=
   - 传入链表 =left= 与 =right=
   - 返回一个链表

2. =vector<int> union_vector(vector<int> & left, vector<int> & right)=
   - 传入数组 =left= 与 =right=
   - 返回一个数组
**** 完整代码
- 首先是合并链表
#+begin_src c++
  list<int> union_list(list<int> & left, list<int> & right) {
    list<int> result = left;
    for (int value : right) {
      auto it = find(result.begin(), result.end(), value);
      if (it == result.end()) {
        result.push_back(value);
      }
    }

    return result;
  }

#+end_src

- 接下来合并数组是类似的
#+begin_src c++
  vector<int> union_vector(vector<int> & left, vector<int> & right) {
    vector<int> result = left;
    for (int value : right) {
      auto it = find(result.begin(), result.end(), value);
      if (it == result.end()) {
        result.push_back(value);
      }
    }

    return result;
  }
#+end_src
**** 测试案例
- 测试代码
#+begin_src c++
  int main() {
    vector<int> nums = {16, 2, 27, 29};
    vector<int> left = nums;
    vector<int> right = nums;

    for(int value: union_vector(left, right)) {
      cout << value << endl;
    }
    return 0;
  }

#+end_src

- 运行结果
#+begin_src sh
  16
  2
  27
  29
#+end_src
**** 时间复杂度
设链表 =left= 的长度为 =M=
设链表 =right= 的长度为 =N=
时间复杂度为 =O(M*N)=
*** A3 合并两个有序链表
**** 问题描述
=left= 和 =right= 是两个有序表，将他们合并成一个有序表
**** 分析
1. 这个程序要参考归并排序，还是很简单的
2. 这里链表和数组的访问操作有些不同，需要注意
3. 链表的访问需要使用迭代器，需要对迭代器调用 =next= 跳转到下一个位置
4. 数组的访问可以通过索引，能够实现随机访问
5. *这里我一个手滑把归并写出来了，应该没事*
**** 函数说明
1. 首先是顶层函数 =merge_sort=
   =void merge_sort(list<int> &nums, compare comp = less)=
   #+begin_src c++
     void merge_sort(list<int> &nums, compare comp = less) {
       vector<int> temp(nums.size());
       int left = firstindex(nums);
       int right = lastindex(nums);

       _merge_sort(nums, left, right, temp, comp);
     }

   #+end_src
2. 顶级函数需要 =_merge_sort= 来帮助完成排序 
   =void _merge_sort(list<int> &nums, int left, int right, vector<int> &temp, compare comp)=
   #+begin_src c++
     void _merge_sort(list<int> &nums, int left, int right, vector<int> &temp,
                      compare comp) {
       if (left < right) {
         int middle = (left + right) / 2;
         _merge_sort(nums, left, middle, temp, comp);
         _merge_sort(nums, middle + 1, right, temp, comp);
         _merge_sorted(nums , left, middle, right, temp, comp);
       }
     }

   #+end_src
3. =_merge_sort= 需要 =_merge_sorted= 来帮助排序，这个才是最主要的
   =void _merge_sorted(list<int> &nums, int left, int middle, int right, vector<int> &temp, compare comp)=
   
**** 完整代码
#+begin_src c++
  void _merge_sorted(list<int> &nums, int left, int middle, int right,
                     vector<int> &temp, compare comp) {
    int _left = left;
    int _right = middle + 1;
    int index = 0;
    auto it = nums.begin();

    while (_left <= middle && _right <= right) {
      auto left_value = *(next(it, _left));
      auto right_value = *(next(it, _right));

      if (comp(left_value, right_value)) {
        temp[index] = left_value;
        index += 1;
        _left += 1;
      } else {
        temp[index] = right_value;
        index += 1;
        _right += 1;
      }
    }

    while (_left <= middle) {
      auto left_value = *(next(it, _left));
      temp[index] = left_value;
      index += 1;
      _left += 1;
    }

    while (_right <= right) {
      auto right_value = *(next(it, _right));
      temp[index] = right_value;
      index += 1;
      _right += 1;
    }

    index = 0;
    while (left <= right) {
      auto position = next(it, left);
      ,*(position) = temp[index];

      left += 1;
      index += 1;
    }
  }

#+end_src
还是别看代码了，写的有点乱，挑几个重要的说
1. 与数组的访问 =nums[index]= 不同，链表的访问需要先获取头节点的迭代器 =iter= ，然后调用 =next(iter, index)= 跳转到目标位置，最后解引用获取值
2. 与数组的修改 =nums[index] = 1= 不同，链表的修改可以通过 =*iter = value= 来实现，类似于修改指针指向的值
**** 测试案例
- 测试代码
#+begin_src c++
  int main() {
    list<int> nums = {3, 38, 44, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48, 2};
    merge_sort(nums);

    for(int num: nums) {
      cout << num << '\t';
    }

    cout << endl;
    return 0;
  }

#+end_src

- 运行结果
#+begin_src sh
  2	2	3	4	15	19	26	27	36	38	44	46	47	48	50	
#+end_src
**** 时间复杂度
- 当使用长度为 =n= 的数组时，时间复杂度为 =O(nlogn)=
- 当使用长度为 =n= 的链表时，时间复杂度为 =O(n^2logn)=

** 10.1.2 栈与队列
*** A1 数制转换问题
**** 题目描述
对于任意一个非负的十进制整数，打印出与其等值的八进制数
**** 题目分析
这里我懒得从键盘输入，直接输入数字，然后返回表示八进制的字符串

***** 定义函数
=transformBase(number::Int)=
- 输入一个整数
- 输出一个字符串，表示其八进制数
***** 测试案例
- =transformBase(1348) == "2504"=
- =transformBase(1234) == "2322"=
**** 完整代码
#+begin_src julia
  function transformBase(number::Int)
    base = 8
    stack = createStack(Int)

    N = number
    div_N = Int(floor(N / base))
    mod_N = N % base
    push!(stack, mod_N)
  
    while div_N != 0
      N = div_N
      div_N = Int(floor(N / base))
      mod_N = N % base
      push!(stack, mod_N)
    end

    return reduce(string, stack; init="")
  end
#+end_src

**** 测试案例
#+begin_src julia
  @test transformBase(1348) == "2504"
  @test transformBase(1234) == "2322"
#+end_src

*** A2 回文判断
**** 题目描述
判断一个字符串是否为回文串，即是否左右对称
**** 题目分析
这个好像反转一下，然后与原字符串中的字符逐个对比就好了
***** 函数定义
=isPalindromic(str::String)=
- 输入一个字符串
- 输出一个 =bool= 类型，判断字符串是否为回文
***** 测试案例
- =isPalindromic("helleh") == true=
**** 完整代码
这东西，一个函数式代码就搞定了
#+begin_src julia
  function isPalindromic(str::String)
    return map(==, str, reverse(str)) |>
      nums -> all(isequal(1), nums)
  end
#+end_src

我用 =Clojure= 再写一遍，更清晰一点
#+begin_src clojure
  (defn palindromic? [string]
    (every (fn [x] 
             (= x 1))
           (map = string (reverse string))))
#+end_src
**** 测试案例
#+begin_src julia
  @test isPalindromic("helleh") == true
#+end_src
*** A4 破解藏头诗
**** 题目描述
输入一首藏头诗，一共四句，每句一行
输出每句的第一个汉字连接在一起的字符串
**** 题目分析
这里需要队列吗，可能我的解决方式不一样吧，我还是不喜欢从终端输入字符串
同样也可以用函数式来写
***** 函数定义
=headPoem(sentences::Vararg{String})=
其中 =Vararg= 指的是可变参数，
***** 测试案例
#+begin_src julia
  headPoem("我",
           "最近",
           "爱上了",
           "你的闺密") == "我最爱你"

#+end_src
**** 完整代码
#+begin_src julia
  headPoem(sentences::Vararg{String}) =  map(first, sentences) |> chs -> reduce(string, chs; init="")
#+end_src

这里我用函数式的 =Clojure= 再写一遍吧
#+begin_src clojure
  (defn head-poem [& sentences]
    (reduce str "" 
            (map first sentences)))
#+end_src
**** 测试案例
#+begin_src julia
  @test headPoem("我",
                 "最近",
                 "爱上了",
                 "你的闺密") == "我最爱你"
#+end_src
*** A5 括号匹配的检验
**** 题目描述
输入圆括号和方括号的任意序列，输出 *匹配* 或 *此串括号匹配不合法*
**** 题目分析
这个其实挺简单
将左括号，左中括号一类的符号归为 *left* 类，将对应的符号归为 *right* 类
遍历每一个符号
- 每碰到 =left= 类符号，就把符号放到一个栈里
- 每碰到 =right= 类符号，取栈顶 =top=
  - 若 =right= 与 =top= 字符相对应，如 =(= 与 =)= ， =[= 与 =]= ，则出栈，进行下一次遍历
  - 若 =right= 与 =top= 字符不匹配，肯定不匹配，推出遍历
- 遍历结束后, *return* 栈是否为空栈
- 注意，遍历前先把第一个符号入栈，否则无法处理 ="]"= 这种开头是 *right* 类符号的情况    
***** 函数定义
=matchPatterns(code::String)=
- 输入字符串序列，只有圆括号和方括号
- 输出括号是否匹配
***** 测试案例
- =matchPatterns("([])()") == true=
- =matchPatterns("]") == false=
- =matchPatterns("]()") == false=
**** 完整代码
#+begin_src julia
  function matchPatterns(code::String)
    stack = createStack(Char)
    isleft(ch::Char) = ch == '[' || ch == '('
    isright(ch::Char) = ch == ']' || ch == ')'
    ismatch(left::Char, right::Char) = begin
      left == '[' && right == ']' || 
        left == '(' && right == ')'
    end
  
    push!(stack, first(code))
  
    for ch in code[2:end]
      if isleft(ch)
        push!(stack, ch)
      else
        if ismatch(first(stack), ch)
          pop!(stack)
        else
          break
        end
      end
    end
  
    return isempty(stack)
  end

#+end_src
**** 测试案例
#+begin_src julia
  @test matchPatterns("([])()") == true
  @test matchPatterns("]") == false
  @test matchPatterns("]()") == false
#+end_src

** 10.1.3 二叉树与树
- 我已提前实现了二叉树的遍历方法
- 题目过于简单，就不用分析了吧
*** 1. 二叉树各节点数值的平均值
**** 函数说明
=average(tree::BinarySearchTree)=
- 输入一个二叉树
- 返回各节点数值的平均值
**** 测试案例
#+begin_src julia
  @test average(tree) == reduce(+, collect(tree)) / length(tree)
#+end_src
**** 完整代码
#+begin_src julia
  function average(tree::BinarySearchTree)
    len = length(tree)
    sum = reduce(+, collect(tree))
    return sum / len
  end
#+end_src
*** 2. 交换每个节点的左右节点
**** 函数说明
#+begin_src julia
  swapnode!(tree::BinarySearchTree)
#+end_src

- 输入一个二叉树
- 将其中每个节点的左右节点交换
- 没有返回值
**** 测试案例
#+begin_src julia
  @testset "practise 2" begin
    swapnode!(tree)
    @info "after swap the tree is " tree
  end
#+end_src

由于代码中向 =tree= 插入的数据都是随机的，测试结果不好展示
其实我懒得展示
**** 完整代码
#+begin_src julia
  function swapnode!(tree::BinarySearchTree)
    swap(node::BinaryNode) = begin
      temp = left(node)
      node.left = node.right
      node.right = temp
    end

    for treenode in bfsiterate(tree)
      swap(treenode)
    end
  end
#+end_src

程序从 =bfsiterate= 返回的迭代器中取出节点 =treenode=
*** 3. 验证 二叉树性质3
**** 函数说明
=verify(tree::BinarySearchTree)=
- 输入一个二叉树
- 输出 =true= 或者 =false= 
**** 测试案例
#+begin_src julia
  @test verify(tree) == true
#+end_src
**** 完整代码
#+begin_src julia
  function verify(tree::BinarySearchTree)
    queue = createQueue(AbstractBinaryNode)
    push!(queue, tree.root)
  
    n0 = n2 = 0
  
    for treenode in bfsiterate(tree)
      # here process the node
      if isleaf(treenode)
        n0 += 1
      elseif !isnil(left(treenode)) && !isnil(right(treenode))
        n2 += 1
      end
    end
  
    return n0 == n2 + 1
  end
#+end_src
*** 4. 中序遍历，后序遍历
**** 函数说明
**** 测试案例
**** 完整代码
*** 5. 判断两个二叉树相等
**** 函数说明
**** 测试案例
**** 完整代码
*** 6. 判断 是否完全二叉树
**** 函数说明
**** 测试案例
**** 完整代码
*** 7. 后序遍历中第一个返回的节点
**** 函数说明
**** 测试案例
**** 完整代码
*** 8. 非递归实现 先序遍历，中序遍历，后序遍历
**** 函数说明
**** 测试案例
**** 完整代码
*** 9. 查看节点所在层次
**** 函数说明
**** 测试案例
**** 完整代码
